<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm on sangminlog</title>
    <link>http://sangm1n.github.io/tags/algorithm/</link>
    <description>Recent content in Algorithm on sangminlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 12 Dec 2020 00:00:00 +0000</lastBuildDate><atom:link href="http://sangm1n.github.io/tags/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>［알고리즘 / Algorithm］ 기준에 따라 데이터를 정렬</title>
      <link>http://sangm1n.github.io/sorting-algorithm/</link>
      <pubDate>Sat, 12 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://sangm1n.github.io/sorting-algorithm/</guid>
      <description>Sorting 정렬은 데이터를 특정한 기준에 따라 순서대로 나열하는 것이다. 정렬 알고리즘은 이진 탐색 의 전처리 과정이기도 하기 때문에 반드시 짚고 넘어가야 한다. 책에서는 다양한 정렬 알고리즘 중 많이 사용하는 선택 정렬, 삽입 정렬, 퀵 정렬, 계수 정렬을 언급했다.
Selection sort 말 그대로 데이터를 선택해서 정렬하는 것이다. 오름차순 정렬을 하고자 할 때 전체 데이터에서 가장 작은 데이터를 맨 앞에 있는 데이터와 바꾸고, 그 다음으로 작은 데이터를 두 번째 데이터와 바꾸고&amp;hellip; 이러한 연산을 반복하면 된다.</description>
    </item>
    
    <item>
      <title>［알고리즘 / Algorithm］ 그래프 탐색을 위한 DFS/BFS</title>
      <link>http://sangm1n.github.io/dfs-bfs-algorithm/</link>
      <pubDate>Thu, 03 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://sangm1n.github.io/dfs-bfs-algorithm/</guid>
      <description>탐색은 많은 양의 데이터 중 원하는 데이터를 찾는 과정으로 그래프나 트리 등의 자료구조에서 자주 다룬다. 대표적인 탐색 알고리즘으로 DFS와 BFS가 있고, 이를 확실히 이해하려면 스택과 큐가 뭔지 알아야 한다.
스택과 큐의 핵심 함수는 삽입(push)과 삭제(pop)다. 따라서 항상 오버플로와 언더플로를 고려해야 한다.
 overflow : 저장 공간을 벗어나 데이터가 넘쳐흐르는 상황 underflow : 데이터가 들어 있지 않은 상태에서 삭제 연산을 수행하는 상황  Stack  LIFO (Last In First Out) : 후입선출로 접시를 쌓는 모습을 연상하면 된다.</description>
    </item>
    
    <item>
      <title>［알고리즘 / Algorithm］ 아이디어를 코드로 바꾸는 구현</title>
      <link>http://sangm1n.github.io/implementation-algorithm/</link>
      <pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>http://sangm1n.github.io/implementation-algorithm/</guid>
      <description>코딩 테스트에서 어떤 문제를 풀든 코드를 작성하는 과정은 필수기 때문에 구현은 모든 문제 유형을 포함하는 개념이라고 볼 수 있다.
Implementation Algorithm 특히 풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제 를 구현 유형의 문제라고 본다. 알고리즘은 간단한데 코드가 굉장히 길어지는 문제, 문자열을 입력받아 한 문자 단위로 끊어서 리스트에 넣어야 하는 문제 등이 까다로운 구현 유형의 문제라고 할 수 있다.
저자는 이 책에서 완전 탐색과 시뮬레이션 두 개의 유형을 구현으로 묶었다.</description>
    </item>
    
    <item>
      <title>［알고리즘 / Algorithm］ 당장 좋은 것만 선택하는 그리디</title>
      <link>http://sangm1n.github.io/greedy-algorithm/</link>
      <pubDate>Sun, 22 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>http://sangm1n.github.io/greedy-algorithm/</guid>
      <description>그리디 알고리즘은 단어 그대로 번역하여 탐욕 알고리즘으로도 소개된다. 탐욕적이라는 말이 무슨 뜻일까?
Greedy Algorithm 그리디 알고리즘에서의 탐욕적이다 라는 말은 현재 상황에서 당장 좋은 것만 고르는 방법을 의미한다. 그래서 어떻게 보면 무식하게 문제를 푸는 방법이라고 볼 수 있다. 단지 매 순간마다 가장 좋아보이는 것을 선택하고, 이 선택이 나중에 어떠한 영향을 미칠지에 대해서는 전혀 고려하지 않는다.
코딩 테스트에서 나오는 그리디 알고리즘 문제들은 타 알고리즘과 비교했을 때 미리 외우고 있지 않아도 풀 수 있을 가능성이 높다고 한다.</description>
    </item>
    
  </channel>
</rss>
