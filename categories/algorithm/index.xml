<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm on sangminlog</title>
    <link>http://sangm1n.github.io/categories/algorithm/</link>
    <description>Recent content in Algorithm on sangminlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 26 Dec 2020 00:00:00 +0000</lastBuildDate><atom:link href="http://sangm1n.github.io/categories/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>［알고리즘 / Algorithm］ 더 알아두면 좋은 기타 알고리즘 (1)</title>
      <link>http://sangm1n.github.io/etc-algorithm/</link>
      <pubDate>Sat, 26 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://sangm1n.github.io/etc-algorithm/</guid>
      <description>이것이 취업을 위한 코딩 테스트다 책 부록에 있는 기타 알고리즘 몇 가지를 정리해봤다.
소수 판별 소수란 1보다 큰 자연수 중 1과 자기 자신을 제외한 자연수로는 나누어 떨어지지 않는 자연수를 뜻한다. 쉽게 말해 1과 자기 자신으로만 나누어지는 자연수이다. 보통 소수인지 아닌지 판별하는 함수를 작성하라고 하면 아래처럼 코드를 짤 것이다.
나도 대부분 위처럼 코드를 작성해왔는데, 백준에서 문제를 풀다보면 빈번히 시간 초과가 뜬다. 1,000,000 처럼 큰 수가 입력으로 들어오면 2부터 999,999까지 모든 수에 대한 연산이 이루어지기 때문에 상당히 비효율적인 코드이다.</description>
    </item>
    
    <item>
      <title>［알고리즘 / Algorithm］ 다양한 그래프 이론 알고리즘</title>
      <link>http://sangm1n.github.io/graph-algorithm/</link>
      <pubDate>Sat, 19 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://sangm1n.github.io/graph-algorithm/</guid>
      <description>이전 포스팅인 DFS/BFS와 최단 경로에서 다룬 내용도 그래프 알고리즘의 한 유형이다. 문제를 접했을 때 서로 다른 개체가 연결되어 있다는 이야기를 들으면 가장 먼저 그래프 알고리즘을 떠올려야 한다.
그래프 알고리즘에 앞서 트리 자료구조에 대해 간략히 짚고 넘어가겠다. 트리는 그래프의 일종으로 여러 노드가 한 노드를 가리킬 수 없는 구조이다.
    그래프 트리     방향성 방향 그래프 혹은 무방향 그래프 방향 그래프   순환성 순환 및 비순환 비순환   루트 노드 존재하지 않음 존재함   노드간 관계성 부모와 자식 관계 없음 부모와 자식 관게   모델 종류 네트워크 모델 계층 모델    Graph Algorithm 그래프는 주로 두 가지 방식으로 구현한다.</description>
    </item>
    
    <item>
      <title>［알고리즘 / Algorithm］ 가장 빠르게 도달하는 최단 경로</title>
      <link>http://sangm1n.github.io/shortest-path-algorithm/</link>
      <pubDate>Thu, 17 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://sangm1n.github.io/shortest-path-algorithm/</guid>
      <description>Shortest Path Algorithm 길 찾기 문제라고도 불리는 최단 경로 알고리즘은 말 그대로 가장 짧은 경로를 찾는 알고리즘이다.
한 지점에서 다른 지점까지의 최단 경로를 구하는 다익스트라 알고리즘과 모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구하는 플로이드 와샬 알고리즘에 대해 알아보자.
Dijkstra Algorithm 다익스트라 알고리즘은 특정한 노드에서 출발하여 다른 노드로 가는 각각의 최단 경로를 구해준다. 음의 간선이 없을 때 정상적으로 동작하며, 매 순간 가장 비용이 적은 노드를 선택하는 과정을 반복하기 때문에 그리디 알고리즘으로 분류된다.</description>
    </item>
    
    <item>
      <title>［알고리즘 / Algorithm］ 범위를 좁혀가는 이진 탐색</title>
      <link>http://sangm1n.github.io/binary-search-algorithm/</link>
      <pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://sangm1n.github.io/binary-search-algorithm/</guid>
      <description>Search Algorithm 이진 탐색에 앞서 순차 탐색에 대해 먼저 이해할 필요가 있다.
Sequential Search 순차 탐색이란 리스트 안의 특정한 데이터를 찾기 위해 맨 앞에서부터 하나씩 확인하는 방법을 뜻한다. 이는 보통 정렬되어 있지 않은 리스트에서 많이 사용하는데, 데이터가 아무리 많아도 시간만 충분하다면 항상 원하는 데이터를 찾을 수 있다.
이처럼 데이터 정렬 여부와 관계없이 항상 맨 앞에서부터 확인하기 때문에 시간복잡도는 O(N) 이다.
Binary Search 반면 이진 탐색은 정렬된 데이터의 탐색 범위를 반씩 좁혀가며 확인한다.</description>
    </item>
    
    <item>
      <title>［알고리즘 / Algorithm］ 중복되는 연산을 줄여주는 다이나믹 프로그래밍</title>
      <link>http://sangm1n.github.io/dynamic-programming-algorithm/</link>
      <pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://sangm1n.github.io/dynamic-programming-algorithm/</guid>
      <description>Dynamic Programming Algorithm 다이나믹 프로그래밍 큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘 기법이다. 기본적으로 아래의 조건을 만족할 때 사용할 수 있다.
 큰 문제를 작은 문제로 나눌 수 있다. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.  이러한 조건을 만족하는 대표적인 문제로는 피보나치 수열이 있다.
Top-down 피보나치 수열을 memoization 기법을 사용하여 해결해보자. 메모이제이션은 한 번 구한 결과를 메모리 공간에 저장해두고 같은 식을 다시 호출하면 저장해둔 결과를 그대로 가져오는 기법이다.</description>
    </item>
    
    <item>
      <title>［알고리즘 / Algorithm］ 기준에 따라 데이터를 정렬</title>
      <link>http://sangm1n.github.io/sorting-algorithm/</link>
      <pubDate>Sat, 12 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://sangm1n.github.io/sorting-algorithm/</guid>
      <description>Sorting Algorithm 정렬은 데이터를 특정한 기준에 따라 순서대로 나열하는 것이다. 정렬 알고리즘은 이진 탐색 의 전처리 과정이기도 하기 때문에 반드시 짚고 넘어가야 한다. 책에서는 다양한 정렬 알고리즘 중 많이 사용하는 선택 정렬, 삽입 정렬, 퀵 정렬, 계수 정렬을 언급했다.
Selection sort 말 그대로 데이터를 선택해서 정렬하는 것이다. 오름차순 정렬을 하고자 할 때 전체 데이터에서 가장 작은 데이터를 맨 앞에 있는 데이터와 바꾸고, 그 다음으로 작은 데이터를 두 번째 데이터와 바꾸고&amp;hellip; 이러한 연산을 반복하면 된다.</description>
    </item>
    
    <item>
      <title>［알고리즘 / Algorithm］ 그래프 탐색을 위한 DFS/BFS</title>
      <link>http://sangm1n.github.io/dfs-bfs-algorithm/</link>
      <pubDate>Thu, 03 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://sangm1n.github.io/dfs-bfs-algorithm/</guid>
      <description>탐색은 많은 양의 데이터 중 원하는 데이터를 찾는 과정으로 그래프나 트리 등의 자료구조에서 자주 다룬다. 대표적인 탐색 알고리즘으로 DFS와 BFS가 있고, 이를 확실히 이해하려면 스택과 큐가 뭔지 알아야 한다.
스택과 큐의 핵심 함수는 삽입(push)과 삭제(pop)다. 따라서 항상 오버플로와 언더플로를 고려해야 한다.
 overflow : 저장 공간을 벗어나 데이터가 넘쳐흐르는 상황 underflow : 데이터가 들어 있지 않은 상태에서 삭제 연산을 수행하는 상황  Stack  LIFO (Last In First Out) : 후입선출로 접시를 쌓는 모습을 연상하면 된다.</description>
    </item>
    
    <item>
      <title>［알고리즘 / Algorithm］ 아이디어를 코드로 바꾸는 구현</title>
      <link>http://sangm1n.github.io/implementation-algorithm/</link>
      <pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>http://sangm1n.github.io/implementation-algorithm/</guid>
      <description>코딩 테스트에서 어떤 문제를 풀든 코드를 작성하는 과정은 필수기 때문에 구현은 모든 문제 유형을 포함하는 개념이라고 볼 수 있다.
Implementation Algorithm 특히 풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제 를 구현 유형의 문제라고 본다. 알고리즘은 간단한데 코드가 굉장히 길어지는 문제, 문자열을 입력받아 한 문자 단위로 끊어서 리스트에 넣어야 하는 문제 등이 까다로운 구현 유형의 문제라고 할 수 있다.
저자는 이 책에서 완전 탐색과 시뮬레이션 두 개의 유형을 구현으로 묶었다.</description>
    </item>
    
    <item>
      <title>［알고리즘 / Algorithm］ 당장 좋은 것만 선택하는 그리디</title>
      <link>http://sangm1n.github.io/greedy-algorithm/</link>
      <pubDate>Sun, 22 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>http://sangm1n.github.io/greedy-algorithm/</guid>
      <description>그리디 알고리즘은 단어 그대로 번역하여 탐욕 알고리즘으로도 소개된다. 탐욕적이라는 말이 무슨 뜻일까?
Greedy Algorithm 그리디 알고리즘에서의 탐욕적이다 라는 말은 현재 상황에서 당장 좋은 것만 고르는 방법을 의미한다. 그래서 어떻게 보면 무식하게 문제를 푸는 방법이라고 볼 수 있다. 단지 매 순간마다 가장 좋아보이는 것을 선택하고, 이 선택이 나중에 어떠한 영향을 미칠지에 대해서는 전혀 고려하지 않는다.
코딩 테스트에서 나오는 그리디 알고리즘 문제들은 타 알고리즘과 비교했을 때 미리 외우고 있지 않아도 풀 수 있을 가능성이 높다고 한다.</description>
    </item>
    
  </channel>
</rss>
