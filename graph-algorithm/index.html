<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="sangmin">
  
  
  
  <link rel="prev" href="http://sangm1n.github.io/shortest-path-algorithm/" />
  <link rel="next" href="http://sangm1n.github.io/etc-algorithm-1/" />
  <link rel="canonical" href="http://sangm1n.github.io/graph-algorithm/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" href="/favicon.ico" type="image/x-icon">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           ［알고리즘 / Algorithm］ 다양한 그래프 이론 알고리즘 | sangminlog
       
  </title>
  <meta name="title" content="［알고리즘 / Algorithm］ 다양한 그래프 이론 알고리즘 | sangminlog">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "http:\/\/sangm1n.github.io"
    },
    "articleSection" : "posts",
    "name" : "［알고리즘 \/ Algorithm］ 다양한 그래프 이론 알고리즘",
    "headline" : "［알고리즘 \/ Algorithm］ 다양한 그래프 이론 알고리즘",
    "description" : "이전 포스팅인 DFS\/BFS와 최단 경로에서 다룬 내용도 그래프 알고리즘의 한 유형이다. 문제를 접했을 때 서로 다른 개체가 연결되어 있다는 이야기를 들으면 가장 먼저 그래프 알고리즘을 떠올려야 한다.\n그래프 알고리즘에 앞서 트리 자료구조에 대해 간략히 짚고 넘어가겠다. 트리는 그래프의 일종으로 여러 노드가 한 노드를 가리킬 수 없는 구조이다.\n    그래프 트리     방향성 방향 그래프 혹은 무방향 그래프 방향 그래프   순환성 순환 및 비순환 비순환   루트 노드 존재하지 않음 존재함   노드간 관계성 부모와 자식 관계 없음 부모와 자식 관게   모델 종류 네트워크 모델 계층 모델    Graph Algorithm 그래프는 주로 두 가지 방식으로 구현한다.",
    "inLanguage" : "en-us",
    "author" : "sangmin",
    "creator" : "sangmin",
    "publisher": "sangmin",
    "accountablePerson" : "sangmin",
    "copyrightHolder" : "sangmin",
    "copyrightYear" : "2020",
    "datePublished": "2020-12-19 00:00:00 \u002b0000 UTC",
    "dateModified" : "2020-12-19 00:00:00 \u002b0000 UTC",
    "url" : "http:\/\/sangm1n.github.io\/graph-algorithm\/",
    "wordCount" : "565",
    "keywords" : [ "Algorithm","Python","Binary-search", "sangminlog"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont "></i></a>&nbsp;<a href="http://sangm1n.github.io">$ cd home/</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/til/" title="">TIL</a>
                
                <a class="menu-item" href="/problem-solving/" title="">PS</a>
                
                <a class="menu-item" href="/categories/" title="">Category</a>
                
                <a class="menu-item" href="/tags/" title="">Tag</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont"></i></a>&nbsp;<a href="http://sangm1n.github.io">$ cd home/</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/til/" title="">TIL</a>
                
                <a class="menu-item" href="/problem-solving/" title="">PS</a>
                
                <a class="menu-item" href="/categories/" title="">Category</a>
                
                <a class="menu-item" href="/tags/" title="">Tag</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">［알고리즘 / Algorithm］ 다양한 그래프 이론 알고리즘</h1>
        <div class="post-meta">
                <span class="post-time"><time datetime=2020-12-19 itemprop="datePublished">December 19, 2020</time>
                </span>
                in
                <i class="iconfont icon-folder"></i>
                <span class="post-category">
                        <a href="http://sangm1n.github.io/categories/algorithm/"> Algorithm </a>
                        
                </span>
        </div>
    </header>
    <div class="post-content">
        

        
            
        

        
        
     
          
          
          

          
          
          

          <p>이전 포스팅인 <a href="https://sangm1n.github.io/dfs-bfs-algorithm/">DFS/BFS</a>와 <a href="https://sangm1n.github.io/shortest-path-algorithm/">최단 경로</a>에서 다룬 내용도 그래프 알고리즘의 한 유형이다. 문제를 접했을 때 <strong>서로 다른 개체가 연결되어 있다</strong>는 이야기를 들으면 가장 먼저 그래프 알고리즘을 떠올려야 한다.</p>
<p>그래프 알고리즘에 앞서 트리 자료구조에 대해 간략히 짚고 넘어가겠다. 트리는 그래프의 일종으로 여러 노드가 한 노드를 가리킬 수 없는 구조이다.</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th>그래프</th>
<th>트리</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">방향성</td>
<td>방향 그래프 혹은 무방향 그래프</td>
<td>방향 그래프</td>
</tr>
<tr>
<td style="text-align:center">순환성</td>
<td>순환 및 비순환</td>
<td>비순환</td>
</tr>
<tr>
<td style="text-align:center">루트 노드</td>
<td>존재하지 않음</td>
<td>존재함</td>
</tr>
<tr>
<td style="text-align:center">노드간 관계성</td>
<td>부모와 자식 관계 없음</td>
<td>부모와 자식 관게</td>
</tr>
<tr>
<td style="text-align:center">모델 종류</td>
<td>네트워크 모델</td>
<td>계층 모델</td>
</tr>
</tbody>
</table>
<h2 id="graph-algorithm">Graph Algorithm</h2>
<p>그래프는 주로 두 가지 방식으로 구현한다.</p>
<ol>
<li>인접 행렬 (<em>Adjacency Matrix</em>) : 2차원 배열 사용
<ul>
<li>메모리 공간이 많이 필요하지만 특정 노드 간 간선의 비용을 <em>O(1)</em> 시간으로 즉시 알 수 있음</li>
</ul>
</li>
<li>인접 리스트 (<em>Adjacency List</em>) : 리스트 사용
<ul>
<li>간선의 개수인 <em>O(E)</em> 만큼만 메모리 공간이 필요하지만 <em>O(V)</em> 시간 소요</li>
</ul>
</li>
</ol>
<p><a href="https://sangm1n.github.io/shortest-path-algorithm/">이전 포스팅</a>에서 다익스트라 알고리즘은 인접 리스트를, 플로이드-워셜 알고리즘은 인접 행렬을 이용하여 구현해봤다.<br>
알고리즘 문제를 풀 때에는 메모리와 시간을 항상 염두해두고 풀어야 한다. 최단 경로를 찾아야 하는 문제에서 <strong>노드의 개수가 적은 경우에는 플로이드-워셜을, 노드와 간선의 개수가 모두 많은 경우에는 우선순위 큐를 이용하는 다익스트라 알고리즘을 이용</strong>하면 유리하다.</p>
<h3 id="disjoint-set">Disjoint Set</h3>
<p>크루스칼 및 위상 정렬 알고리즘을 공부하기 전에 그래프 알고리즘에서 중요하게 사용되는 <code>disjoint-set</code>에 대해 살펴보자. 수학에서 서로소 집합이란 공통 원소가 없는 두 집합을 의미한다.<br>
서로소 집합 자료구조는 <code>union</code>과 <code>find</code> 연산으로 조작할 수 있어 <em>union-find 자료구조</em> 라고도 불린다.</p>
<ul>
<li><em>union</em> : 2개의 원소가 포함된 집합을 하나의 집합으로 합치는 연산</li>
<li><em>find</em> : 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산</li>
</ul>
<p>트리를 이용해 서로소 집합을 계산하는 알고리즘은 다음과 같은 방식으로 동작한다.</p>
<ol>
<li>union 연산을 확인하여 서로 연결된 두 노드 A와 B 확인한다.<br>
1-1. A와 B의 루트 노드 A&rsquo;와 B&rsquo;를 찾는다.<br>
1-2. A&rsquo;를 B&rsquo;의 부모 노드로 설정한다. (B' → A')</li>
<li>모든 union 연산을 처리할 때까지 1번 과정을 반복한다.</li>
</ol>
<p><img src="https://user-images.githubusercontent.com/46131688/102684866-8b18a680-421f-11eb-8511-0f0c7173bd5e.png" alt=""></p>
<p>서로소 집합은 무방향 그래프에서 사이클을 판변할 때 사용할 수 있다. 부모 테이블에는 루트 노드 값이 들어가기 때문에 두 노드씩 비교하면서 루트 노드가 같다면 사이클이 발생한 것으로 간주한다.</p>
<h3 id="spanning-tree">Spanning Tree</h3>
<p>신장 트리란 <strong>하나의 그래프가 있을 때 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프</strong>를 의미한다. 사실 모든 노드가 서로 연결되어 있고, 사이클을 이루지 않는다는 것이 트리의 성립 조건이기도 하다. 신장 그래프라고 부르지 않고 신장 트리라고 부르는 이유이다.<br>
아래 그래프에서 주황색으로 연결된 부분을 신장 트리라고 부르며, 하나의 그래프에서 이와 같이 여러 개의 신장 트리가 나올 수 있다.</p>
<p><img src="https://user-images.githubusercontent.com/46131688/102685012-b2bc3e80-4220-11eb-93f0-984ba90c4988.png" alt=""></p>
<h4 id="kruskal-algorithm">Kruskal Algorithm</h4>
<p>이러한 신장 트리 중 최소 비용으로 만들 수 있는 신장 트리를 찾는 것을 <em>최소 비용 신장 트리 알고리즘</em> 이라고 하며 <strong>크루스칼 알고리즘</strong>이 대표적이다.</p>
<ol>
<li>간선 데이터를 비용에 따라 오름차순으로 정렬한다.</li>
<li>간선을 하나씩 확인하며 현재 간선이 사이클을 발생시키는지 확인한다.<br>
2-1. 사이클 발생 X → 최소 신장 트리에 포함
2-2. 사이클 발생 O → 최소 신장 트리에 포함하지 않음</li>
<li>모든 간선에 대하여 2번의 과정을 반복한다.</li>
</ol>
<p>모든 간선에 대해 정렬한 뒤 거리가 짧은 간선부터 집합에 포함시키기 때문에 그리디 알고리즘으로 분류된다. 사이클 발생 여부는 위에서 언급했듯이 find_parent 함수를 이용하면 된다.</p>
<h4 id="topology-sort">Topology Sort</h4>
<p>위상 정렬은 정렬 알고리즘의 일종으로 순서가 정해져 있는 작업을 차례대로 수행해야 할 때 사용할 수 있다. 책에 나온 문장을 그대로 인용하자면 <strong>방향 그래프의 모든 노드를 방향성에 거스르지 않도록 순서대로 나열</strong>하는 것이라고 한다.<br>
객체 지향 프로그래밍 → 자료구조 → 알고리즘 순서와 같이 교과목 선후수 체계를 떠올리면 이해하기 쉬운데, 위상 정렬 알고리즘은 진입차수를 기준으로 동작한다. 진입차수는 <strong>특정 노드로 들어오는 간선의 개수</strong>를 뜻한다.</p>
<ol>
<li>진입차수가 0인 노드를 큐에 넣는다.</li>
<li>큐가 빌 때까지 아래의 과정을 반복한다.<br>
2-1. 큐에서 원소를 꺼내 해당 노드에서 출발하는 간선을 그래프에서 제거한다.<br>
2-2. 새롭게 진입차수가 0이 된 노드를 큐에 넣는다.</li>
</ol>
<p><img src="https://user-images.githubusercontent.com/46131688/102685363-7807d580-4223-11eb-9f44-b4c8f7c00231.png" alt=""></p>
<p>위상 정렬은 차례대로 모든 노드를 확인하면서 해당 노드에서 출발하는 간선을 제거하기 때문에 <em>O(V + E)</em> 만큼의 시간이 소요된다.</p>
<hr>
<h4 id="참고">참고</h4>
<ul>
<li><em>이것이 취업을 위한 코딩 테스트다</em></li>
</ul>

    </div>
    

    <div class="post-tags">
        
            <section>
            <i class="iconfont icon-tag"></i>Tag(s) - 
            
            <span class="tag"><a href="http://sangm1n.github.io/tags/algorithm/">
                    #Algorithm</a></span>
            
            <span class="tag"><a href="http://sangm1n.github.io/tags/python/">
                    #Python</a></span>
            
            <span class="tag"><a href="http://sangm1n.github.io/tags/binary-search/">
                    #Binary-search</a></span>
            
            </section>
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="http://sangm1n.github.io">home</a></span>
        </section>
    </div>

    <script src="https://utteranc.es/client.js"
        repo="sangm1n/blog-comments"
        issue-term="pathname"
        label="comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
    </script>

    <div class="post-nav">
        
        <a href="http://sangm1n.github.io/shortest-path-algorithm/" class="prev" rel="prev" title="［알고리즘 / Algorithm］ 가장 빠르게 도달하는 최단 경로"><i class="iconfont icon-left"></i>&nbsp;［알고리즘 / Algorithm］ 가장 빠르게 도달하는 최단 경로</a>
         
        
        <a href="http://sangm1n.github.io/etc-algorithm-1/" class="next" rel="next" title="［알고리즘 / Algorithm］ 더 알아두면 좋은 기타 알고리즘 (1)">［알고리즘 / Algorithm］ 더 알아두면 좋은 기타 알고리즘 (1)&nbsp;<i class="iconfont icon-right"></i></a>
        
    </div>

    <div class="post-comment">
          
                 
          
    </div>
</article>
          </div>
		   </main>
      <footer class="footer">
  <div class="copyright">
    &copy;   
    <span class="author" itemprop="copyrightHolder"
      ><a href="http://sangm1n.github.io">sangmin</a> |
    </span>
     
    <span
      >Powered by
      <a href="https://gohugo.io/" target="_blank" rel="external nofollow"
        >Hugo</a
      >
  </div>
</footer>












    
     <link href="//lib.baomitu.com/lightgallery/1.6.11/css/lightgallery.min.css" rel="stylesheet">  
      
     <script src="/js/vendor_gallery.min.js" async="" ></script>
    
  




     </div>
  </body>
</html>
